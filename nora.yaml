substitutions:
  devicename: noradesk
  devicename_upper: NoraDesk

<<: !include ./.base.yaml

sensor:
## DHT22
- platform: dht
  pin: D4
  model: AM2302
  temperature:
    name: "${devicename_upper} Temperature"
  humidity:
    name: "${devicename_upper} Humidity"
  update_interval: 30s

# Rotary Encoder
- platform: rotary_encoder
  pin_a: D7
  pin_b: D6
  id: knob
  restore_mode: ALWAYS_ZERO
  min_value: 0
  max_value: 255
  resolution: 4
  on_value:
    then:
      ## Default: White Brightness
    - if:
        condition:
          lambda: 'if (id(current_mode).state == "brightness") { return true; } else { return false; }'
        then:
        - script.execute: white_light
      ## Color
    - if:
        condition:
          lambda: 'if (id(current_mode).state == "color") { return true; } else { return false; }'
        then:
        - script.execute: colored_light
      ## Color Brightness
    - if:
        condition:
          lambda: 'if (id(current_mode).state == "color_brightness") { return true; } else { return false; }'
        then:
        - light.turn_on:
            id: strip
            white: 0%
            brightness: 100%
            color_brightness: !lambda "return x / 255.0;"


binary_sensor:
- platform: gpio
  pin:
    number: D5
    inverted: true
  id: button
  filters:
  - delayed_on: 10ms
  - delayed_off: 10ms
  ## Start a 3s timer when holding the button and turn off strip
  on_press:
    then:
    - script.execute: start_timer
  on_release:
    then:
    - script.stop: start_timer
  on_click:
    ## Short press
  - then:
    - if:
        condition:
          light.is_off: strip
        then:
        - light.turn_on: strip
        else:
        - script.execute: next_mode
    ## Long press
  - min_length: 1000ms
    max_length: 3000ms
    then:
    - light.toggle: strip


light:
- platform: neopixelbus
  type: GRBW
  variant: WS2813
  pin: D2
  num_leds: 10
  restore_mode: ALWAYS_OFF
  id: strip
  name: "Strip"
  default_transition_length: 0.3s
  effects:
  - addressable_rainbow:
  - addressable_color_wipe:
  - addressable_scan:
      scan_width: 3
  - pulse:


select:
  ## Current Mode
- platform: template
  id: current_mode
  internal: true
  optimistic: true
  options:
  - brightness
  - color
  - color_brightness
  on_value:
  - logger.log:
      format: "CURRENT STATE IS: %s"
      args: ['x.c_str()']

globals:
- id: current_mode_int
  type: int
  restore_value: no
  initial_value: '0'

script:
  ## Turn off strip if button press > 3s
- id: start_timer
  mode: restart
  then:
  - delay: 1s
  - wait_until:
      condition:
        binary_sensor.is_off: button
      timeout: 1s
  - light.turn_off: strip

  ## Script for activating colored light
- id: colored_light
  then:
  - lambda: |-
      float v = id(knob).state / 255;
      if (v != v) { // Test for NaN, after boot knob is inited with NaN (weird!)
        v = 0;
      }
      float a = (1 - v) / 0.2;
      int X = floor(a);
      float Y = (floor)(255 * (a - X));
      float r = 0;
      float g = 0;
      float b = 0;

      switch (X) {
        case 0: r=255; g=Y; b=0; break;
        case 1: r=255-Y; g=255; b=0; break;
        case 2: r=0; g=255; b=Y; break;
        case 3: r=0; g=255-Y; b=255; break;
        case 4: r=Y; g=0; b=255; break;
        case 5: r=255; g=0; b=255; break;
      }

      auto call = id(strip).turn_on();
      call.set_color_mode(ColorMode::RGB_WHITE);
      call.set_brightness(1.0);
      call.set_color_brightness(0.6);
      call.set_white(0);
      call.set_rgb(r / 255, g / 255, b / 255);
      call.perform();

  ## Script for activating white light
- id: white_light
  then:
  - light.turn_on:
      id: strip
      white: 100%
      brightness: !lambda 'return id(knob).state / 255;'
      color_brightness: 0%

  ## Whenever this script is called the next mode is activated
- id: next_mode
  then:
    ## Set next mode
  - lambda: |-
      if (id(current_mode_int) < 2) {
        id(current_mode_int) += 1;
      } else {
        id(current_mode_int) = 0;
      }

      switch (id(current_mode_int)) {
        case 1:
          id(current_mode).publish_state("color");
          break;
        case 2:
          id(current_mode).publish_state("color_brightness");
          break;
        default:
          id(current_mode).publish_state("brightness");
          break;
      }
    ## After changing mode, update the current light state (white / colored)
  - if:
      condition:
        lambda: 'if (id(current_mode).state == "brightness") { return true; } else { return false; }'
      then:
      - script.execute: white_light
  - if:
      condition:
        lambda: 'if (id(current_mode).state == "color") { return true; } else { return false; }'
      then:
      - script.execute: colored_light
