substitutions:
  devicename: stairs
  devicename_upper: Stairs

  ## Number of LEDs in strip (15 per stair)
  num_leds: "115"
  ## 15 LEDs x 15 stairs = 225 LEDs in strip
  # num_leds: "225"

  ## Time between toggling on/off the stairs
  step_delay: 0.5s

<<: !include .base32.yaml

wifi:
  fast_connect: true

## Animation speed
number:
- platform: template
  id: animation_speed
  name: Animation Speed
  optimistic: true
  step: 32
  min_value: 32
  max_value: 640

binary_sensor:
  ## PIR
- platform: gpio
  pin: GPIO18
  name: "${devicename_upper} Motion Ground Floor"
  id: pir_ground_floor
  device_class: motion
  on_press:
    if:
      # When the lights are out
      condition:
        and: &lightsareout
        - light.is_off: strip
        - light.is_off: steps
        - light.is_off: step1
        - light.is_off: step2
        - light.is_off: step3
        # - light.is_off: step4
        # - light.is_off: step5
        # - light.is_off: step6
        # - light.is_off: step7
        # - light.is_off: step8
        # - light.is_off: step9
        # - light.is_off: step10
        # - light.is_off: step11
        # - light.is_off: step12
        # - light.is_off: step13
        # - light.is_off: step14
        # - light.is_off: step15
      then:
      - script.execute: bottom_to_top_on
      - script.execute:
          id: bottom_to_top_off
          delay_ms: 15000
      else: &extend
      # When bottom_to_top_off is running, trigger again
      - if:
          condition:
            - script.is_running: bottom_to_top_off
          then:
            - script.execute:
                id: bottom_to_top_off
                delay_ms: 5000
      # When top_to_bottom_off is running, trigger again
      - if:
          condition:
            - script.is_running: top_to_bottom_off
          then:
            - script.execute:
                id: top_to_bottom_off
                delay_ms: 5000

- platform: gpio
  pin: GPIO19
  name: "${devicename_upper} Motion First Floor"
  id: pir_first_floor
  device_class: motion
  on_press:
    if:
      # When the lights are out
      condition:
        and: *lightsareout
      then:
      - script.execute: top_to_bottom_on
      - script.execute:
          id: top_to_bottom_off
          delay_ms: 15000
      else: *extend

  ## Button
- platform: gpio
  pin:
    number: GPIO5
    mode: INPUT_PULLUP
    inverted: true
  id: button
  on_press:
    if:
      condition:
        and: *lightsareout
      then:
        light.turn_on:
          id: strip
          transition_length: 0.3s
          color_mode: RGB_WHITE
          brightness: 0.4
          white: 1.0
          color_brightness: 0 ## Required to keep the RGB leds off
          red: 0
          blue: 0
          green: 0
      else:
      - light.turn_off: strip
      - light.turn_off: steps
      - light.turn_off: step1
      - light.turn_off: step2
      - light.turn_off: step3
      - light.turn_off: step4
      - light.turn_off: step5
      - light.turn_off: step6
      - light.turn_off: step7
      # - light.turn_off: step8
      # - light.turn_off: step9
      # - light.turn_off: step10
      # - light.turn_off: step11
      # - light.turn_off: step12
      # - light.turn_off: step13
      # - light.turn_off: step14
      # - light.turn_off: step15

## LED Strip
light:
- platform: neopixelbus
  variant: SK6812
  type: GRBW
  pin: GPIO4
  num_leds: "${num_leds}"
  id: strip
  name: "Full Strip"
  restore_mode: ALWAYS_OFF
  effects:
  - addressable_rainbow:
      width: 115
  - addressable_scan:
      scan_width: 3
      move_interval: 20ms
  - addressable_twinkle:
  - addressable_fireworks:
  - addressable_flicker:
      name: Flicker

# Steps
- platform: partition
  name: Steps
  id: steps
  segments:
  - single_light_id: step1
  - single_light_id: step2
  - single_light_id: step3
  - single_light_id: step4
  - single_light_id: step5
  - single_light_id: step6
  - single_light_id: step7
  # - single_light_id: step8
  # - single_light_id: step9
  # - single_light_id: step10
  # - single_light_id: step11
  # - single_light_id: step12
  # - single_light_id: step13
  # - single_light_id: step14
  # - single_light_id: step15
  effects:
  - addressable_rainbow:
      width: 7
      # width: 15
  - addressable_color_wipe:
      name: Police
      add_led_interval: 500ms
      colors:
      - red: 100%
        blue: 0%
        green: 0%
        white: 0%
        num_leds: 1
      - red: 0%
        blue: 100%
        green: 0%
        white: 0%
        num_leds: 1
  - addressable_scan:
      move_interval: 300ms
  - addressable_lambda: &warpcore
      name: Warp Core
      lambda: |-
        // Static variables keep their value even when
        // stopping and starting the effect again
        static uint32_t ms = 0;
        static int16_t pos = 0;

        uint16_t cycle = id(animation_speed).state;

        // EXIT PREMATURELY WHEN IT'S NOT TIME TO RUN
        // EITHER USE number.animation_speed OR SET A VALUE IN MS, EG. 16
        if (millis() - ms < cycle) {
          return;
        }

        // PULSE SIZE
        byte size = 1;

        // PADDING
        byte pad = floor((size - 1) / 2);
        byte offset = size % 2 == 0 ? 1 : 0;

        // DETERMINE MIDDLE
        uint16_t middle = ceil(it.size() / 2);

        // To reset static when stopping and starting the effect
        // again you can use the initial_run variables
        if (initial_run) {
          ms = 0;
          pos = 0 - pad;
        }

        it.all() = Color::BLACK;

        // START & END
        int16_t start = pos;
        int16_t end = it.size() - 1 - pos;

        // PAD BEFORE
        for (int i = 1; i <= pad; i++) {
          // FROM END
          if (end + i < it.size() && end + i >= middle) {
            it[end + i] = current_color;
          }
          // FROM START
          if (start + i > 0 && start + i < middle) {
            it[start + i] = current_color;
          }
        }

        // CENTER PIXEL
        if (start >= 0 && start < middle) {
          it[start] = current_color;

          // ADD ONE EXTRA PIXEL AFTER CENTER WHEN SIZE IS AN EVEN NUMBER
          if (offset > 0 && start - offset >= 0 && start - offset < middle) {
            it[start - offset] = current_color;
          }
        }

        // MIRRORED CENTER PIXEL
        if (end < it.size() && end >= middle) {
          it[end] = current_color;

          // ADD ONE EXTRA PIXEL AFTER CENTER WHEN SIZE IS AN EVEN NUMBER
          if (offset > 0 && end - offset < it.size() && end - offset >= middle) {
            it[end - offset] = current_color;
          }
        }

        // PAD AFTER
        for (int i = 1; i <= pad; i++) {
          // FROM START
          if (start - i - offset > 0 && start - i - offset < middle) {
            it[start - i - offset] = current_color;
          }
          // FROM END
          if (end - i - offset >= middle && end - i - offset < it.size()) {
            it[end - i - offset] = current_color;
          }
        }

        // INCREASE POS
        pos++;

        if (pos > it.size()) {
          pos = 0 - pad;
        }

        // WAIT FOR 500 MS (MAX) AFTER ANIMATION HAS REACHED THE MIDDLE (REACTION CHAMBER)
        // ALLOW ANIMATION TO END SAFELY
        if (pos > (middle + pad + 1 + offset) && (pos - middle) * cycle > 500) {
          pos = 0 - pad;
        }

        // UPDATE MS FOR THE NEXT RUN
        ms = millis();

# Separate full strip into 15 partitions (steps / stairs)
- platform: partition
  id: step1
  segments:
  - id: strip
    from: 0
    to: 14
- platform: partition
  id: step2
  segments:
  - id: strip
    from: 15
    to: 29
    reversed: true
- platform: partition
  id: step3
  segments:
  - id: strip
    from: 30
    to: 44
- platform: partition
  id: step4
  segments:
  - id: strip
    from: 45
    to: 59
    reversed: true
- platform: partition
  id: step5
  segments:
  - id: strip
    from: 60
    to: 74
- platform: partition
  id: step6
  segments:
  - id: strip
    from: 75
    to: 89
    reversed: true
- platform: partition
  id: step7
  segments:
  - id: strip
    from: 90
    to: 104
# - platform: partition
#   id: step8
#   segments:
#   - id: strip
#     from: 105
#     to: 119
#     reversed: true
# - platform: partition
#   id: step9
#   segments:
#   - id: strip
#     from: 120
#     to: 134
# - platform: partition
#   id: step10
#   segments:
#   - id: strip
#     from: 135
#     to: 149
#     reversed: true
# - platform: partition
#   id: step11
#   segments:
#   - id: strip
#     from: 150
#     to: 164
# - platform: partition
#   id: step12
#   segments:
#   - id: strip
#     from: 165
#     to: 179
#     reversed: true
# - platform: partition
#   id: step13
#   segments:
#   - id: strip
#     from: 190
#     to: 194
# - platform: partition
#   id: step14
#   segments:
#   - id: strip
#     from: 195
#     to: 209
#     reversed: true
# - platform: partition
#   id: step15
#   segments:
#   - id: strip
#     from: 210
#     to: 224

script:
- id: top_to_bottom_on
  then:
    ## Turn on the lights in proper order
  - light.turn_on: &color
      id: step1
      transition_length: 0.3s
      color_mode: RGB_WHITE
      brightness: 0.4
      white: 1.0
      color_brightness: 0 ## Required to keep the RGB leds off
      red: 0
      blue: 0
      green: 0
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step2
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step3
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step4
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step5
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step6
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step7
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step8
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step9
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step10
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step11
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step12
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step13
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step14
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step15

    ## Wait a few seconds
  # - delay: !lambda return delay_ms;

- id: top_to_bottom_off
  mode: restart
  parameters:
    delay_ms: int
  then:
    ## Turn off the lights in proper order after initial delay
  - delay: !lambda return delay_ms;
  - light.turn_off: step1
  - delay: ${step_delay}
  - light.turn_off: step2
  - delay: ${step_delay}
  - light.turn_off: step3
  - delay: ${step_delay}
  - light.turn_off: step4
  - delay: ${step_delay}
  - light.turn_off: step5
  - delay: ${step_delay}
  - light.turn_off: step6
  - delay: ${step_delay}
  - light.turn_off: step7
  # - delay: ${step_delay}
  # - light.turn_off: step8
  # - delay: ${step_delay}
  # - light.turn_off: step9
  # - delay: ${step_delay}
  # - light.turn_off: step10
  # - delay: ${step_delay}
  # - light.turn_off: step11
  # - delay: ${step_delay}
  # - light.turn_off: step12
  # - delay: ${step_delay}
  # - light.turn_off: step13
  # - delay: ${step_delay}
  # - light.turn_off: step14
  # - delay: ${step_delay}
  # - light.turn_off: step15

- id: bottom_to_top_on
  then:
    ## Turn on the lights in proper order
  # - light.turn_on:
  #     <<: *color
  #     id: step15
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step14
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step13
  # - light.turn_on:
  #     <<: *color
  #     id: step12
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step11
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step10
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step9
  # - delay: ${step_delay}
  # - light.turn_on:
  #     <<: *color
  #     id: step8
  # - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step7
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step6
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step5
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step4
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step3
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step2
  - delay: ${step_delay}
  - light.turn_on:
      <<: *color
      id: step1

- id: bottom_to_top_off
  mode: restart
  parameters:
    delay_ms: int
  then:
    ## Turn off the lights in proper order after initial delay
  - delay: !lambda return delay_ms;
  # - light.turn_off: step15
  # - delay: ${step_delay}
  # - light.turn_off: step14
  # - delay: ${step_delay}
  # - light.turn_off: step13
  # - delay: ${step_delay}
  # - light.turn_off: step12
  # - delay: ${step_delay}
  # - light.turn_off: step11
  # - delay: ${step_delay}
  # - light.turn_off: step10
  # - delay: ${step_delay}
  # - light.turn_off: step9
  # - delay: ${step_delay}
  # - light.turn_off: step8
  # - delay: ${step_delay}
  - light.turn_off: step7
  - delay: ${step_delay}
  - light.turn_off: step6
  - delay: ${step_delay}
  - light.turn_off: step5
  - delay: ${step_delay}
  - light.turn_off: step4
  - delay: ${step_delay}
  - light.turn_off: step3
  - delay: ${step_delay}
  - light.turn_off: step2
  - delay: ${step_delay}
  - light.turn_off: step1
